import logging
import re

from bip.email.gmail import get_message_text_from_payload, get_header_value, \
    get_last_threads, gmail_api_client
from bip.config import test_email
from bip import utils


def _create_chunk_metadata(chunk, message, chunk_index):
    """Create metadata for the chunk, with the id of the thread, id of the
    message, date of the message, and chunk position

    :param chunk: the chunk
    :param message: the message
    :return: the metadata
    """
    subject = get_header_value(message['payload']['headers'], 'Subject')
    date = message['internalDate']
    metadata = {
        'subject': subject,
        'message_id': message['id'],
        'date': date if date else "No date",
        'chunk_index': chunk_index,
        'thread_id': message['threadId'],
        'source': subject,
        'text': chunk,
    }
    return metadata


CHUNK_HEADER_SEPARATOR = "*******************\n\n"


def _enrich_chunk(chunk, message, index, total):
    """Add subject, sender, main recipients and date as header text to
    the chunk.

    :param chunk: the chunk to enrich
    :param message: the message to get the headers from
    :return: the enriched chunk
    """
    subject = get_header_value(message['payload']['headers'], 'Subject')
    sender = get_header_value(message['payload']['headers'], 'From')
    date = get_header_value(message['payload']['headers'], 'Date')
    recipients = get_header_value(message['payload']['headers'], 'To')
    enriched_chunk = f"Subject: {subject}\n" \
                     f"From: {sender}\n" \
                     f"To: {recipients}\n" \
                     f"Date: {date}\n" \
                     f"Message part {index+1} of {total}\n" \
                     f"{CHUNK_HEADER_SEPARATOR}" \
                     f"{chunk}"
    return enriched_chunk


def _create_chunks(message, chunk_size=1000):
    """Create chunks from the message.

    :param message: the message to chunk
    :return: the chunks
    """
    message_text = get_message_text_from_payload(message['payload'])
    chunks = []
    chunk_overlap = int(chunk_size / 8)
    chunk_step = chunk_size - chunk_overlap
    for i in range(0, len(message_text), chunk_step):
        chunks.append(message_text[i:i + chunk_step])
    return chunks


def cut_message(message, chunk_size=1000):
    """
    Cut the message in chunks, enrich them, create the metadata for each
    chunk and return the outcome

    Documentation on Message object:
    https://developers.google.com/gmail/api/v1/reference/users/messages

    :param message: the message to cut
    :return: the enriched chunks and the chunks metadatas
    """
    # compute chunks
    chunks = _create_chunks(message, chunk_size=chunk_size)
    if not chunks:
        logging.warning("Empty message")
        return [], []

    # compute enriched chunks
    def enrich_chunk(c, i):
        return _enrich_chunk(c, message, i, len(chunks))
    enriched_chunks = list(map(enrich_chunk, chunks, range(len(chunks))))

    # compute chunks metadatas
    def chunk_metadata(chunk, index):
        return _create_chunk_metadata(chunk, message, index)
    chunks_metadatas = list(map(chunk_metadata,
                                enriched_chunks,
                                range(len(chunks))))

    return enriched_chunks, chunks_metadatas


def glue_chunks(enriched_chunks,
                keep_header=True,
                max_tokens=3000,
                delimiter="\n---\n"):
    """
    Glue chunks together, keeping the header of the first chunk if keep_header
    is True. Add the delimiter between chunks.

    Meant to be used with enriched_chunks and metadatas as generated by
    `cut_message`.

    Chunks will be selected until the max_tokens limit is reached, in the order
    they have been provided -- with the intent that the order corresponds to an
    importance score.

    They will then be stitched together in the original order of their
    appearance in the message, as indicated in their header -- with the intent
    that the final text will then make more sense.

    :param enriched_chunks: the enriched chunks
    :param max_tokens: the maximum number of tokens to keep
    :param keep_header: whether to keep the header of the first chunk
    :param delimiter: the delimiter to use between chunks
    :return: the glued chunks
    """
    # get the header text from a chunk
    # and remove the "Message part X of Y" from the header
    header_text = enriched_chunks[0].split(CHUNK_HEADER_SEPARATOR)[0]
    header_text = re.sub(r'Message part \d+ of \d+', '', header_text)

    # Extract the index of each chunk from the header
    def get_chunk_index(chunk):
        return int(re.search(r'Message part (\d+) of \d+', chunk).group(1))
    chunk_indices = [get_chunk_index(chunk) for chunk in enriched_chunks]

    # remove the header from each chunk
    cleaned_chunks = [chunk.split(CHUNK_HEADER_SEPARATOR)[1]
                      for chunk in enriched_chunks]

    # remove texts until the max_tokens limit is reached (using
    # util.count_tokens)
    total_tokens = utils.count_tokens(header_text) if keep_header else 0
    selected_chunks = []
    for chunk in cleaned_chunks:
        if total_tokens + utils.count_tokens(chunk) > max_tokens:
            break
        selected_chunks.append(chunk)
        total_tokens += utils.count_tokens(chunk)

    # order remaining chunks according to their index
    selected_chunks = [chunk for _, chunk in sorted(zip(chunk_indices,
                                                        selected_chunks))]
    # join the texts with the delimiter
    header_text = (header_text + CHUNK_HEADER_SEPARATOR) if keep_header else ""
    return header_text + delimiter.join(selected_chunks)


def chunk_id(message_id, chunk_index):
    """
    Compute the chunk id from the message id and the chunk index

    :param message_id: the message id
    :param chunk_index: the chunk index
    :return: the chunk id
    """
    return f"{message_id}-{chunk_index}"


def test_chunks():
    client = gmail_api_client(test_email)

    # Get last threads from gmail, store their content in a chroma database
    for thread in get_last_threads(client, 3):
        enriched_chunks, chunks_metadatas = cut_message(thread['messages'][0])
        print("Enriched chunks:" + str(len(enriched_chunks)))
        print("Chunks metadatas:" + str(len(chunks_metadatas)))
        for chunk, metadata in zip(enriched_chunks, chunks_metadatas):
            print(chunk)
            print(metadata)
            print("")


if __name__ == '__main__':
    test_chunks()
